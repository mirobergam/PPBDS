---
output_yaml:
  - _output.yml
---

# (APPENDIX) Appendix {-}


<!-- This chapter is an excellent idea, but also fundamentally flawed in implemention. First, it is a great idea to have a dedicated resource, designed for our use, which we can point students to. We don't want to explain 100 times how to confirm that git is installed correctly. Second, the actual implementation here stinks. To fix: -->

<!-- 1) Don't reinvent the wheel. We should never explain X is X is already explained elsewhere online for free. Our main goal is to curate and organize an excellent list of other references. -->

<!-- 2) Use high quality sources.  -->
<!--   + For git/Github that is Happy Git for the R User. Maybe also [this](https://emmal73.github.io/github_slides.html). -->
<!--   + For R/RStudio issues that is anything associated with RStudio.  -->
<!--   + For command lines, we probably want to write our own, based heavily on  [The UNIX Workbench](https://seankross.com/the-unix-workbench/), but with all the work done form the terminal window in RStudio. (How differently does the RStudio Terminal window behave across operating systems.)  Perhaps the single biggest confusion among students is not understanding how a process can be run from two different places. This causes endless problems when students build their own Shiny App later. -->
<!--   + For workflow issues, we want [What They Forgot to Teach You About R](https://rstats.wtf/), which is CC so we might use a lot of it. -->

<!-- 3) Point, don't tell. We don't want this to be too long/overwhelming. -->

<!-- 4) Connect to weeks 1 and 2. This is assigned for week 1, but it will naturally spill over into the following two weeks. Also, connect the order of the topics to the order in which we use them in class. Maybe they are separate chapters, one for each week? -->

<!-- 5) Create some tutorial questions. The only way we can force students to do this stuff is to assign it. -->

<!-- 6) Make sure to cover obscure topics which matter to us. For example, the .gitignore file and, maybe, what the .Rproj file does. Make sure, at the beginning, to require the setting up of RStudio correctly. Specifically:

* rstudioapi::writeRStudioPreference(name = "load_workspace", value = FALSE) doesn't load the previous workspace upon startup
 * rstudioapi::writeRStudioPreference(name = "save_workspace", value = "never") doesn't save workspace after R session quits without prompting the user for an answer 

-->

<!-- 7) Consider making the **fs** package a major part of the presentation. This helps avoid dealing with cross-OS issues ourselves. -->

<!-- 8) With luck, we can delete the high level images/ directory since we won't use it anymore. -->



# Productivity

```{r, include=FALSE, echo=FALSE}
if(knitr::is_html_output()){
  knitr::opts_chunk$set(out.width = "500px", 
                        out.extra='style="display: block; margin-left: auto; margin-right: auto; background-color: #000; padding:3px;"')
} else{
  knitr::opts_chunk$set(out.width = "4in")
}

img_path <- "images/img/"
screenshots <- list.files(file.path(img_path, "windows-screenshots"))
screenshots <- file.path(img_path, "windows-screenshots", screenshots)
mac_screenshots <- list.files(file.path(img_path, "mac-screenshots"))
mac_screenshots <- file.path(img_path,"mac-screenshots", mac_screenshots)
```

This chapter is meant to be skimmed. Only read those portions which apply to your computer set up and which you do not already understand.

Do not use point-and-click approaches for data analysis. Use scripting languages, such as R, since they are more flexible and facilitate reproducibility. Similarly, do not use point-and-click approaches to organizing files and document preparation. We will learn freely available tools that the vast majority of professionals use every day. 

Three general guiding principles that motivate what we learn here are 1) be systematic when organizing your filesystem, 2) automate when possible, and 3) minimize the use of the mouse. As you become more proficient at coding, you will find that 1) you want to minimize the time you spend remembering what you called a file or where you put it, 2) if you find yourself repeating the same task over and over, there is probably a way to automate, and 3) anytime your fingers leave the keyboard, it results in loss of productivity. 

A data analysis project is not always a dataset and a script. A typical data analysis challenge may involve several parts, each involving several data files, including files containing the scripts we use to analyze data. Keeping all this organized can be challenging. We will learn to use the _Unix shell_ for managing files and directories on your computer. Using Unix will permit you to use the keyboard, rather than the mouse, when creating folders, moving from directory to directory, and renaming, deleting, or moving files. We also provide specific suggestions on how to keep the filesystem organized.

The data analysis process is also iterative and adaptive. As a result, we are constantly editing our scripts and reports. In this chapter, we introduce you to the version control system _Git_, which is a powerful tool for keeping track of these changes. We also introduce you to GitHub^[http://github.com], a service that permits you to host and share your code. We will demonstrate how you can use this service to facilitate collaborations. **Keep in mind that another positive benefit of using GitHub is that you can easily showcase your work to potential employers**.

Finally, we learn to write reports in R markdown, which permits you to incorporate text and code into a single document. We will demonstrate how, using the `knitr` package, we can write reproducible and aesthetically pleasing reports by running the analysis and generating the report simultaneously. 

We will put all this together using the powerful integrated desktop environment RStudio^[https://www.rstudio.com/]. 

## Set Up

Before getting started, we need to make sure you have access to a _terminal_ and that Git is installed. The terminal is integrated into Mac and Linux systems, but Windows users will have to install an _emulator_. There are many emulator options available, but here we show how to install Git Bash because it can be done as part of the Windows Git installation. Because of the differences in Mac and Windows, the sections in this chapter are divided accordingly.

### Accessing the terminal on a Mac {#terminal-on-mac}

The terminal is our window into the Unix world. On a Mac you can access a terminal by opening the application in the Utilities folder:

```{r, echo=FALSE,  out.width="45%"}
knitr::include_graphics(mac_screenshots[1:3]) 
```

You can also use the Spotlight feature on the Mac by typing command-spacebar, then type _Terminal_. 

Yet another way to access the terminal is from RStudio. In the _Console_ pane you should see a _Terminal_ tab. If you click on this tab you will open a terminal window.

### Installing Git on the Mac

1. Start by opening a terminal as described in the previous section.

2. Once you start the terminal, you will see a console like this:

```{r, echo=FALSE}
knitr::include_graphics(mac_screenshots[3]) 
```

3. You might have Git installed already. One way to check is by asking for the version by typing:

```{bash, eval=FALSE, echo=TRUE}
git --version
```

    If you get a version number back, it is already installed. If not, you will get the following message:

```{r, echo=FALSE}
knitr::include_graphics(mac_screenshots[4])
```

    and you will be asked if you want to install it. You should click _Install_:

```{r, echo=FALSE}
knitr::include_graphics(mac_screenshots[5])
```

4. This will take you through the installation process:

```{r, echo=FALSE, out.width = "45%",  out.extra=""}
knitr::include_graphics(mac_screenshots[6:8])
```

5. Once installed, you can check for the version again and it should show you something like this:

```{r, echo=FALSE}
knitr::include_graphics(mac_screenshots[9])
```

Congratulations. You have installed Git on your Mac.


### Installing Git and Git Bash on Windows

There are several pieces of software that will permit you to perform Unix commands on Windows. We will be using Git Bash as it interfaces with RStudio and it is automatically installed when we install Git for Windows.

1. Start by searching for _Git for Windows_ on your browser and clicking on the link from _git-scm.com_.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[57])
```

2. This will take you to the _Download Git_ page from which you can download the _most recent maintained build_:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[58])
```

3. You can then accept to run the installer and agree to the license:

```{r, echo=FALSE, out.width = "45%",  out.extra=""}
knitr::include_graphics(screenshots[59:60])
```

4. In one of the installation steps, you will be asked to pick the default editor for Git. Unless you are already a _vi_ or _vim_ user, we recommend against selecting _vim_ which might be the default. If you do not recognize an editor you are familiar with among the options given, we recommend that you select _nano_ as your default editor for Git since it is the easiest to learn:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[61])
```

5. The next installation decision is actually an **important one**. This installation process installs Git Bash. We recommend that you select _Git and optional Unix tools from the Windows Command Prompt_ as this will permit you to learn Unix from within RStudio. However, if you do this, **some commands that run on your Windows command line will stop working**. If you do not use your Windows command line, then this should not be a problem. Also, most, if not all, of these Windows command lines have a Unix equivalent that you will be able to use now.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[62])
```

6. You can now continue selecting the default options.

```{r, echo=FALSE, out.width = "45%",  out.extra=""}
knitr::include_graphics(screenshots[63:65])
```

```{r, echo=FALSE, out.width = "45%",  out.extra=""}
knitr::include_graphics(screenshots[66:67])
```

You have now installed Git on Windows.

### Accessing the terminal on Windows {#terminal-on-windows}

Now that Git Bash is installed, we can access the terminal either through RStudio or by opening Git Bash directly. We recommend that Windows users always using the terminal via RStudio.

To access the terminal through RStudio, we need to change a preference so that Git Bash becomes the default Unix shell in RStudio. In RStudio, go to preferences (under the File pull down menu), then select _Terminal_, then select _Git Bash_:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[68])
```

To check that you in fact are using Git Bash in RStudio, you can open a _New Terminal_ in RStudio:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[69])
```

It should look something like this:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[70])
```

## Organizing with Unix {#unix}

Unix is the operating system of choice in data science. We will introduce you to the Unix way of thinking using an example: how to keep a data analysis project organized. We will learn some of the most commonly used commands along the way. When searching for Unix resources, keep in mind that other terms used to describe what we will learn here are _Linux_, _the shell_ and _the command line_. Basically, what we are learning is a series of commands and a way of thinking that facilitates the organization of files without using the mouse.

<!-- Add Unix Workbench resource -->

To serve as motivation, we are going to start constructing a directory using Unix tools and RStudio.

### Naming convention

Before you start organizing projects with Unix you want to pick a name convention that you will use to systematically name your files and directories. This will help you find files and know what is in them.

In general you want to name your files in a way that is related to
their contents and specifies how they relate to other files. The Smithsonian Data Management Best Practices^[https://library.si.edu/sites/default/files/tutorial/pdf/filenamingorganizing20180227.pdf] has "five precepts of file naming and organization" and they are:

>> * Have a distinctive, human-readable name that gives an indication of the content.
>> * Follow a consistent pattern that is machine-friendly.
>> * Organize files into directories (when necessary) that follow a consistent pattern.
>> * Avoid repetition of semantic elements among file and directory names.
>> * Have a file extension that matches the file format (no changing extensions!)

Follow The Tidyverse Style Guide^[https://style.tidyverse.org/].


### The terminal {#the-terminal}

Instead of clicking, dragging, and dropping to organize our files and folders, we will be typing Unix commands into the terminal. The way we do this is similar to how we type commands into the R console, but instead of generating plots and statistical summaries, we will be organizing files on our system.

Once you have a terminal open, you can start typing commands. You should see a blinking cursor at the spot where what you type will show up. This position is called the _command line_. Once you type something and hit enter on Windows or return on the Mac, Unix will try to execute this command. If you want to try out an example, type this command into your command line:


```{bash, eval=FALSE}
echo "hello world"
```

Executing this line should print out `hello world`, then return back to the command line.

Notice that you can't use the mouse to move around in the terminal. You have to use the keyboard. To go back to a command you previously typed, you can use the up arrow.

Note that above we included a chunk of code showing Unix commands in the same way we have previously shown R commands. We will make sure to distinguish when the command is meant for R and when it is meant for Unix.


### The filesystem {#filesystem}

We refer to all the files, folders, and programs on your computer as _the filesystem_.  Keep in mind that folders and programs are also files, but this is a technicality we rarely think about and ignore in this book. 

### Directories and subdirectories

Think of your filesystem as a series of nested folders, each containing files, folders, and executables.

Here is a visual representation of the structure we are describing:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path, "unix/filesystem.png"))
```

In Unix, we refer to folders as _directories_. Directories that are inside other directories are often referred to as _subdirectories_. So, for example, in the figure above, the directory _docs_ has two subdirectories: _reports_ and _resumes_, and _docs_ is a subdirectory of _home_.

### The home directory

The _home_ directory is where all your stuff is kept, as opposed to the system files that come with your computer, which are kept elsewhere. In the figure above, the directory called _home_ represents your home directory, but that is rarely the name used. On your system, the name of your home directory is likely the same as your username on that system. Below are an example on Windows and Mac showing a home directory, in this case, named _rafa_:

```{r, out.width="45%", echo=FALSE}
knitr::include_graphics(c(screenshots[100], mac_screenshots[42]))
```


Now, look back at the figure showing a filesystem. Suppose you are using a point-and-click system and you want to remove the file _cv.tex_. Imagine that on your screen you can see the _home_ directory. To erase this file, you would double click on the _home_ directory, then _docs_, then  _resumes_, and then drag _cv.tex_ to the trash. Here you are experiencing the hierarchical nature of the system: _cv.tex_ is a file inside the _resumes_ directory, which is a subdirectory inside the _docs_ directory, which is a subdirectory of the _home_ directory.

Now suppose you can't see your home directory on your screen. You would somehow need to make it appear on your screen. One way to do this is to navigate from what is called the _root_ directory all the way to your home directory. Any filesystem will have what is called a _root_ directory, which is the directory that contains all directories. The _home_ directory shown in the figure above will usually be two or more levels from the root. On Windows, you will have a structure like this:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path, "unix/windows-filesystem-from-root.png"))
```

while on the Mac, it will be like this:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"unix/mac-filesystem-from-root.png"))
```


**Note for Windows Users:** The typical R installation will make your _Documents_ directory your home directory in R. This will likely be different from your home directory in Git Bash. Generally, when we discuss home directories, we refer to the Unix home directory which for Windows, in this book, is the Git Bash Unix directory.

### Working directory {#working-directory}

The concept of a _current location_ is part of the point-and-click experience: at any given moment we are _in a folder_ and see the content of that folder. As you search for a file, as we did above, you are experiencing the concept of a current location: once you double click on a directory, you change locations and are now _in that folder_, as opposed to the folder you were in before.

In Unix, we don't have the same visual cues, but the concept of a _current location_ is indispensable. We refer to this as the _working directory_. Each terminal window you have open has a working directory associated with it.

How do we know what is our working directory? To answer this, we learn our first Unix command: `pwd`, which stands for _print working directory_.  This command returns the working directory.

Open a terminal and type:

```{bash, eval=FALSE}
pwd
```

We do not show the result of running this command because it will be quite different on your system compared to others. If you open a terminal and type `pwd` as your first command, you should see something like `/Users/yourusername` on a Mac or something like `/c/Users/yourusername` on Windows. The character string returned by calling `pwd` represents your working directory. When we first open a terminal, it will start in our home directory so in this case the working directory is the home directory.

Notice that the forward slashes `/` in the strings above separate directories. So, for example, the location `/c/Users/rafa` implies that our working directory is called `rafa` and it is a subdirectory of `Users`, which is a subdirectory of `c`, which is a subdirectory of the root directory. The root directory is therefore represented by just a forward slash: `/`.

### Paths {#paths}

We refer to the string returned by `pwd` as the _full path_ of the working directory. The name comes from the fact that this string spells out the _path_ you need to follow to get to the directory in question from the root directory. Every directory has a full path. Later, we will learn about _relative paths_, which tell us how to get to a directory from the working directory.

In Unix, we use the shorthand `~` as a nickname for your home directory. So, for example, if `docs` is  a directory in your home directory, the full path for _docs_ can be written like this `~/docs`.

Most terminals will show the path to your working directory right on the command line. If you are using default settings and open a terminal on the Mac, you will see that right at the command line you have something like `computername:~ username` with `~` representing your working directory, which in this example is the home directory `~`. The same is true for the Git Bash terminal where you will see something like `username@computername MINGW64 ~`, with the working directory at the end. When we change directories, we will see this change on both Macs and Windows.

## Unix commands

We will now learn a series of Unix commands that will permit us to prepare a directory for a data science project. We also provide examples of commands that, if you type into your terminal, will return an error. This is because we are assuming the filesystem in the earlier diagram. Your filesystem is different. In the next section, we will provide examples that you can type in.

### `ls`: Listing directory content

In a point-and-click system, we know what is in a directory because we see it. In the terminal, we do not see the icons. Instead, we use the command `ls` to list the directory content.

To see the content of your home directory, open a terminal and type:

```{bash, eval=FALSE}
ls
```

We will see more examples soon.

### `mkdir` and `rmdir`: make and remove a directory

When we are preparing for a data science project, we will need to create directories. In Unix, we can do this with the command `mkdir`, which stands for _make directory_.

Because you will soon be working on several projects, we highly recommend creating a directory called _projects_ in your home directory.

You can try this particular example on your system. Open a terminal and type:

```{bash, eval=FALSE}
mkdir projects
```

If you do this correctly, nothing will happen: no news is good news. If the directory already exists, you will get an error message and the existing directory will remain untouched.

To confirm that you created these directories, you can list the directories:

```{bash, eval=FALSE}
ls
```
You should see the directories we just created listed. Perhaps you can also see many other directories that come pre-installed on your computer.

For illustrative purposes, let's make a few more directories. You can list more than one directory name like this:

```{bash, eval=FALSE}
mkdir docs teaching
```

You can check to see if the three directories were created:

```{bash, eval=FALSE}
ls
```

If you made a mistake and need to remove the directory, you can use the command `rmdir` to remove it.



```{bash, eval=FALSE}
mkdir junk
rmdir junk
```

This will remove the directory as long as it is empty. If it is not empty, you will get an error message and the directory will remain untouched. To remove directories that are not empty, we will learn about the command `rm` later.

### `cd`: navigating the filesystem by changing directories

Next we want to create directories inside directories that we have already created. We also want to avoid pointing and clicking our way through the filesystem. We explain how to do this in Unix, using the command line.

Suppose we open a terminal and our working directory is our home directory. We want to change our working directory to `projects`. We do this using the `cd` command, which stands for _change directory_:

```{bash, eval=FALSE}
cd projects
```

To check that the working directory changed, we can use a command we previously learned to see our location:
```{bash, eval=FALSE}
pwd
```

Our working directory should now be `~/projects`. Note that on your computer the home directory `~` will be spelled out to something like `/c/Users/yourusername`).

**Important Pro Tip**: In Unix you can auto-complete by hitting tab. This means that we can type `cd d` then hit tab. Unix will either auto-complete if `docs` is the only directory/file starting with `d` or show you the options. Try it out! Using Unix without auto-complete will make it unbearable.

When using `cd`, we can either type a full path, which will start with `/` or `~`, or a _relative path_. In the example above, in which we typed `cd projects`, we used a relative path. **If the path you type does not start with `/` or `~`, Unix will assume you are typing a relative path, meaning that it will look for the directory in your current working directory**. So something like this will give you an error:

```{bash, eval=FALSE}
cd Users
```

because there is no `Users` directory in your working directory.

Now suppose we want to move back to the directory in which `projects` is a subdirectory, referred to as the _parent directory_. We could use the full path of the parent directory, but Unix provides a shortcut for this: the parent directory of the working directory is represented with two dots: `..`, so to move back we simply type:

```{bash, eval=FALSE}
cd ..
```

You should now be back in your home directory which you can confirm using `pwd`.

Because we can use full paths with `cd`, the following command:
```{bash, eval=FALSE}
cd ~
```

will always take us back to the home directory, no matter where we are in the filesystem.

The working directory also has a nickname, which is a single `.`, so if you type

```{bash, eval=FALSE}
cd .
```

you will not move. Although this particular use of `.` is not useful, this nickname does come in handy sometimes. The reasons are not relevant for this section, but you should still be aware of this fact.

In summary, we have learned that when using `cd` we either stay put, move to a new directory using the desired directory name, or move back to the parent directory using `..`.

When typing directory names, we can concatenate directories with the forward-slashes. So if we want a command that takes us to the `projects` directory no matter where we are in the filesystem, we can type:

```{bash, eval=FALSE}
cd ~/projects
```

which is equivalent to writing the entire path out. For example, in Windows we would write something like

```{bash, eval=FALSE}
cd /c/Users/yourusername/projects
```

The last two commands are equivalent and in both cases we are typing the full path.


When typing out the path of the directory we want, either full or relative, we can concatenate directories with the forward-slashes. We already saw that we can move to the `projects` directory regardless of where we are by typing the full path like this:

```{bash, eval=FALSE}
cd ~/projects
```


We can also concatenate directory names for relative paths. For instance, if we want to move back to the parent directory of the parent directory of the working directory, we can type:

```{bash, eval=FALSE}
cd ../..
```

Here are a couple of final tips related to the  `cd` command. First, you can go back to whatever directory you just left by typing:

```{bash, eval=FALSE}
cd -
```

This can be useful if you type a very long path and then realize you want to go back to where you were, and that too has a very long path.

Second, if you just type:

```{bash, eval=FALSE}
cd
```

you will be returned to your home directory.


### Some examples

Let's explore some examples of using `cd`. To help visualize, we will show the graphical representation of our filesystem vertically:

```{r, echo=FALSE, out.width="40%"}
knitr::include_graphics(file.path(img_path, "unix/filesystem-vertical.png"))
```

Suppose our working directory is `~/projects` and we want to move to `figs` in `project-1`.

Here it is convenient to use relative paths:

```{bash, eval=FALSE}
cd project-1/figs
```

Now suppose our working directory is `~/projects` and we want to move to `reports` in `docs`, how can we do this?

One way is to use relative paths:

```{bash, eval=FALSE}
cd ../docs/reports
```

Another is to use the full path:

```{bash, eval=FALSE}
cd ~/docs/reports
```

If you are trying this out on your system, remember to use auto-complete.

Let's examine one more example. Suppose we are in `~/projects/project-1/figs` and want to change to `~/projects/project-2`. Again, there are two ways.

With relative paths:

```{bash, eval=FALSE}
cd ../../proejct-2
```

and with full paths:

```{bash, eval=FALSE}
cd ~/projects/project-2
```

### More Unix commands

#### `mv`: moving files

In a point-and-click system, we move files from one directory to another by dragging and dropping. In Unix, we use the `mv` command.

**Warning**: `mv` will not ask "are you sure?" if your move results in overwriting a file.

Now that you know how to use full and relative paths, using `mv` is relatively straightforward. The general form is:

```{bash, eval=FALSE}
mv path-to-file path-to-destination-directory
```

For example, if we want to move the file `cv.tex` from `resumes` to `reports`, you could use the full paths like this:

```{bash, eval=FALSE}
mv ~/docs/resumes/cv.tex ~/docs/reports/
```

You can also use relative paths. So you could do this:

```{bash, eval=FALSE}
cd ~/docs/resumes
mv cv.tex ../reports/
```

or this:

```{bash, eval=FALSE}
cd ~/docs/reports/
mv ../cv.tex ./
```

Notice that in the last one we used the working directory shortcut `.` to give a relative path as the destination directory.

We can also use `mv` to change the name of a file. To do this, instead of the second argument being the destination directory, it also includes a filename. So, for example, to change the name from `cv.tex` to `resume.tex`, we simply type:

```{bash, eval=FALSE}
cd ~/docs/resumes
mv cv.tex resume.tex
```

We can also combine the move and a rename. For example:


```{bash, eval=FALSE}
cd ~/docs/resumes
mv cv.tex ../reports/resume.tex
```

And we can move entire directories. To move the `resumes` directory into `reports`, we do as follows:


```{bash, eval=FALSE}
mv ~/docs/resumes ~/docs/reports/
```

It is important to add the last `/` to make it clear you do not want to rename the `resumes` directory to `reports`, but rather move it into the `reports` directory.

#### `cp`: copying files

The command `cp` behaves similar to `mv` except instead of moving, we copy the file, meaning that the original file stays untouched.

So in all the `mv` examples above, you can switch `mv` to `cp` and they will copy instead of move with one exception: we can't copy entire directories without learning about arguments, which we do later.

#### `rm`: removing files

In point-and-click systems, we remove files by dragging and dropping them into the trash or using a special click on the mouse. In Unix, we use the `rm` command.

**Warning**: Unlike throwing files into the trash, `rm` is permanent. Be careful!

The general way it works is as follows:
```{bash, eval=FALSE}
rm filename
```

You can actually list files as well like this:

```{bash, eval=FALSE}
rm filename-1 filename-2 filename-3
```

You can use full or relative paths. To remove directories, you will have to learn about arguments, which we do later.

#### `less`: looking at a file

Often you want to quickly look at the content of a file. If this file is a text file, the quickest way to do is by using the command `less`. To look a the file `cv.tex`, you do this:

```{bash, eval=FALSE}
cd ~/docs/resumes
less cv.tex
```

To exit the viewer, you type `q`. If the files are long, you can use the arrow keys to move up and down. There are many other keyboard commands you can use within `less` to, for example, search or jump pages. You will learn more about this in a later section. If you are wondering why the command is called `less`, it is because the original was called `more`, as in "show me more of this file". The second version was called `less` because of the saying "less is more".



### Advanced Unix

Most Unix implementations include a large number of powerful tools and utilities. We have just learned the very basics here. We recommend that you use Unix as your main file management tool. It will take time to become comfortable with it, but as you struggle, you will find yourself learning just by looking up solutions on the internet. In this section, we superficially cover slightly more advanced topics. The main purpose of the section is to make you aware of what is available rather than explain everything in detail.

#### Arguments

Most Unix commands can be run with arguments. Arguments are typically defined by using a dash `-` or two dashes `--` (depending on the command) followed by a letter or a word. An example of an argument is the `-r` behind `rm`. The `r` stands for recursive and the result is that files and directories are removed recursively, which means that if you type:

```{bash, eval=FALSE}
rm -r directory-name
```

all files, subdirectories, files in subdirectories, subdirectories in subdirectories, and so on, will be removed. This is equivalent to throwing a folder in the trash, except you can't recover it. Once you remove it, it is deleted for good.  Often, when you are removing directories, you will encounter files that are protected. In such cases, you can use the argument `-f` which stands for `force`.

You can also combine arguments. For instance, to remove a directory regardless of protected files, you type:

```{bash, eval=FALSE}
rm -rf directory-name
```

Remember that once you remove there is no going back, so use this command very carefully.

A command that is often called with argument is `ls`. Here are some examples:

```{bash, eval=FALSE}
ls -a
```
The `a` stands for all. This argument makes `ls` show you all files in the directory, including hidden files. In Unix, all files starting with a `.` are hidden. Many applications create hidden directories to store important information without getting in the way of your work. An example is `git` (which we cover in depth later). Once you initialize a directory as a git directory with `git init`, a hidden directory called `.git` is created. Another hidden file is the `.gitignore` file.

Another example of using an argument is:

```{bash, eval=FALSE}
ls -l
```

The `l` stands for long and the result is that more information about the files is shown.

It is often useful to see files in chronological order. For that we use:

```{bash, eval=FALSE}
ls -t
```

and to reverse the order of how files are shown you can use:

```{bash, eval=FALSE}
ls -r
```

We can combine all these arguments to show more information for all files in reverse chronological order:

```{bash, eval=FALSE}
ls -lart
```

Each command has a different set of arguments. In the next section, we learn how to find out what they each do.


#### Pipes

The help pages are typically long and if you type the commands above to see the help, it scrolls all the way to the end. It would be useful if we could save the help to a file and then use `less` to see it. The `pipe`, written like this `|`, does something similar. It _pipes_ the results of a command to the command after the `pipe`. This is similar to the pipe `%>%` that we use in R. To get more help we thus can type:

```{bash, eval=FALSE}
man ls | less
```

or in Git Bash:

```{bash, eval=FALSE}
ls --help | less
```

This is also useful when listing files with many files. We can type:

```{bash, eval=FALSE}
ls -lart | less
```

#### Wild cards

Some of the most powerful aspects of Unix are the _wild cards_. Suppose we want to remove all the temporary html files produced while trouble shooting for a project. Imagine there are dozens of files. It would be quite painful to remove them one by one. In Unix, we can actually write an expression that means all the files that end in `.html`. To do this we type _wild card_: `*`. As discussed in the data wrangling part of this book, this character means any number of any combination of characters. Specifically, to list all html files, we would type:

```{bash, eval=FALSE}
ls *.html
```

To remove all html files in a directory, we would type:

```{r, eval=FALSE}
rm *.html
```

The other useful wild card is the `?` symbol. This means any single character. So if all the files we want to erase have the form
`file-001.html` with the numbers going from 1 to 999, we can type:

```{bash, eval=FALSE}
rm file-???.html
```

This will only remove files with that format.

We can combine wild cards. For example, to remove all files with the name `file-001` regardless of suffix, we can type:


```{bash, eval=FALSE}
rm file-001.*
```

__Warning: Combining rm with the `*` wild card can be dangerous. There are combinations of these commands that will erase your entire filesystem without asking "are you sure?". Make sure you understand how it works before using this wild card with the rm command.__


#### Executables

In Unix, all programs are files. They are called executables. So `ls`, `mv` and `git` are all files. But where are these program files? You can find out using the command `which`:

```{bash, eval=FALSE}
which git
```

That directory is probably full of program files. The directory `/usr/bin` usually holds many program files. If you type:

```{bash, eval=FALSE}
ls /usr/bin
```

in your terminal, you will see several executable files.

There are other directories that usually hold program files. The Application directory in the Mac or Program Files directory in Windows are examples.

When you type `ls`, Unix knows to run a program which is an executable that is stored in some other directory. So how does Unix know where to find it? This information is included in the environmental variable `$PATH`. If you type:

```{bash, eval=FALSE}
echo $PATH
```

you will see a list of directories separated by `:`. The directory `/usr/bin` is probably one of the first ones on the list.

Unix looks for program files in those directories in that order. Although we don't teach it here, you can actually create executables yourself. However, if you put it in your working directory and this directory is not on the path, you can't run it just by typing the command. You get around this by typing the full path. So if your command is called my-ls, you can type:

```{bash, eval=FALSE}
./my-ls
```

Once you have mastered the basics of Unix, you should consider learning to write your own executables as they can help alleviate repetitive work.

#### Permissions and file types

If you type:

```{bash, eval=FALSE}
ls -l
```

At the beginning, you will see a series of symbols like this `-rw-r--r--`. This string indicates the type of file: regular file `-`, directory `d`, or executable `x`. This string also indicates the permission of the file: is it readable? writable? executable?  Can other users on the system read the file? Can other users on the system edit the file? Can other users execute if the file is executable? This is more advanced than what we cover here, but you can learn much more in a Unix reference book.


### File manipulation in R

We can also perform file management from within R. The key functions to learn about can be seen by looking at the help file for `?files`. These are the base commands, however. A more modern approach is to use the **fs** package --- where *fs* stands for *filesytem* --- for all file manipulation in R.


```{r, include=FALSE}
knitr::opts_chunk$set(out.width = NULL, out.extra = NULL)
```

## Git and GitHub {#git}

Here we provide some details on Git and GitHub. However, we are only scratching the surface. To learn more about this topic, read [*Happy Git and GitHub for the useR*](http://happygitwithr.com/). There are three main reasons to use Git and GitHub.

1. Sharing: Even if we do not take advantage of the advanced and powerful version control functionality, we can still use Git and GitHub to share our code. We have already shown how we can do this with RStudio.

2. Collaborating: Once you set up a central repo, you can have multiple people make changes to code and keep versions synched. GitHub provides a free service for centralized repos. GitHub also has a special utility, called a _pull request_, that can be used by anybody to suggest changes to your code. You can easily either accept or deny the request.

3. Version control: The version control capabilities of Git permit us to keep track of changes we make to our code. We can also revert back to previous versions of files. Git also permits us to create _branches_ in which we can test out ideas, then decide if we _merge_ the new branch with the original.

Here we focus on the sharing aspects of Git and GitHub and refer the reader to the links above to learn more about this powerful tool.

### GitHub accounts

After installing git^[https://rafalab.github.io/dsbook/accessing-the-terminal-and-installing-git.html], the first step is to get a GitHub account. Basic GitHub accounts are free. To do this, go to [GitHub](github.com) where you will see a box in which you can sign up.

<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[71])
```
-->

You want to pick a name carefully. It should be short, easy to remember and to spell, somehow related to your name, and professional. This last one is important since you might be sending potential employers a link to your GitHub account. In the example below, I am sacrificing on the ease of spelling to incorporate my name. Your initials and last name are usually a good choice. If you have a very common name, then this may have to be taken into account. A simple solution would be to add numbers or spell out part of your name.

The account I use for my research, _rafalab_, is the same one I use for my webpage^[http://rafalab.org] and Twitter^[http://twitter.com/rafalab], which makes it easy to remember for those that follow my work.


Once you have a GitHub account, you are ready to connect Git and RStudio to this account.

A first step is to let Git know who we are. This will make it easier to connect with GitHub. We start by opening a terminal window in RStudio (remember you can get one through _Tools_ in the menu bar). Now we use the `git config` command to tell Git who we are. We will type the following two commands in our terminal window:

```{bash, eval=FALSE, echo=TRUE}
git config --global user.name "Your Name"
git config --global user.mail "your@email.com"
```

You need to use the email account that you used to open your GitHub account. The RStudio session should look something like this:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[85])
```

You start by going to the _Global Options_, selecting _Git/SVN_, and then you enter a path for the Git executable we just installed.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[74])
```

On the Windows default installation, this will be _C:/Program File/Git/bin/git.exe_, but you should find it by browsing your system as this can change from system to system. Now to avoid entering our GitHub password every time we try to access our repository, we will create what is called an _SSH RSA Key_. RStudio can do this for us automatically if we click on the _Create RSA Key_ button:

```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[75:76])
```

You can follow the default instructions as shown below:

```{r, echo=FALSE, out.width = "45%"}
knitr::include_graphics(screenshots[77:78])
```

Git, RStudio and GitHub should now be able to connect and we are ready to create a first GitHub code repository.

### GitHub repositories {#github-repos}

You are now ready to create a GitHub repository (repo). The general idea is that you will have at least two copies of your code: one on your computer and one on GitHub. If you add collaborators to this project, then each will have a copy on their computer. The GitHub copy is usually considered the _master_ copy that each collaborator syncs to. Git will help you keep all the different copies synced.

As mentioned, one of the advantages of keeping code on a GitHub repository is that you can easily share it with potential employers interested in seeing examples of your work. Because many data science companies use version control systems, like Git, to collaborate on projects, they might also be impressed that you already know at least the basics.

The first step in creating a repo for your code is to initialize on GitHub. Because you already created an account, you will have a page on GitHub with the URL `http://github.com/username`.

To create a repo, first log in to your account by clicking the _Sign In_ button on [https://github.com](http://github.com). You might already be signed in, in which case the _Sign In_ button will not show up.
<!--

```{r, echo=FALSE}
knitr::include_graphics(screenshots[79])
```
-->
If signing in, you will have to enter your username and password. We recommend you set up your browser to remember this to avoid typing it in each time.
<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[80])
```
-->

Once on your account, you can click on _Repositories_ and then click on _New_ to create a new repo:


```{r, out.width="45%", echo=FALSE}
knitr::include_graphics(screenshots[81:82])
```


You will then want to choose a good descriptive name for the project. In the future, you might have dozens of repos so keep that in mind when choosing a name. Here we will use `homework-0`. We recommend you make the repo public. If you want to keep it private, you will have to pay a monthly charge.


```{r, echo=FALSE}
knitr::include_graphics(screenshots[83])
```

You now have your first repo on GitHub. The next step will be to _clone it_ on your computer and start editing and syncing using Git.

To do this, it is convenient to copy the link provided by GitHub specifically to connect to this repo, using Git as shown below. We will later need to copy and paste this so make sure to remember this step.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[84])
```



### Overview of Git {#git-overview}


The main actions in Git are to:

1. **pull** changes from the remote repo, in this case the GitHub repo
2. **add** files, or as we say in the Git lingo _stage_ files
3. **commit** changes to the local repo
4. **push** changes to the _remote_ repo, in our case the GitHub repo

To effectively permit version control and collaboration in Git, files move across four different areas:

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-layout.png"))
```

But how does it all get started? There are two ways: we can clone an existing repo or initialize one. We will explore cloning first.

#### Clone

We are going to _clone_ an existing _Upstream Repository_. You can see it on GitHub here: [https://github.com/rairizarry/murders](https://github.com/rairizarry/murders). By visiting this page, you can see multiple files and directories. This is the Upstream Repository. By clicking the green clone button, we can copy the repo's URL `https://github.com/rairizarry/murders.git`.

But what does _clone_ mean? Rather than download all these files to your computer, we are going to actually copy the entire Git structure, which means we will add the files and directories to each of the three local stages: Working Directory, Staging Area, and Local Repository. When you clone, all three are exactly the same to start.

You can quickly see an example of this by doing the following. Open a terminal and type:


```{r, echo=FALSE}
wd <- getwd() ##so we set back later. We are about to start switching dirs
if(file.exists("git-example")) unlink("git-example", recursive=TRUE, force = TRUE)
```


```{bash, eval=FALSE}
pwd
mkdir git-example
cd git-example
git clone https://github.com/rairizarry/murders.git
cd murders
```

You now have cloned a GitHub repo and have a working Git directory, with all the files, on your system.

```{bash, eval=FALSE}
ls
```

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-clone.png"))
```


The _Working Directory_ is the same as your Unix working directory. When you edit files using an editor such as RStudio, you change the files in this area and only in this area. Git can tell you how these files relate to the versions of the files in other areas with the command `git status`:


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path, "git/git-status.png"))
```

If you check the status now, you will see that nothing has changed and you get the following message:

```{bash, eval=FALSE}
git status
```

Now we are going to make changes to these files. Eventually, we want these new versions of the files to be tracked and synched with the upstream repo. But we don't want to keep track of every little change: we don't want to sync until we are sure these versions are final enough to share. For this reason, edits in the staging area are not kept by the version control system.

To demonstrate, we add a file to the staging area with the `git add` command. Below we create a file using the Unix `echo` command just as an example (in reality you would use RStudio):

```{bash, eval=FALSE}
echo "test" >> new-file.txt
```

We are also adding a temporary file that we do not want to track at all:

```{bash, eval=FALSE}
echo "temporary" >> tmp.txt
```

Now we can stage the file we eventually want to add to our repository:

```{bash, eval=FALSE}
git add new-file.txt
```

Notice what the status says now:

```{bash, eval=FALSE}
git status
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-add.png"))
```

Because `new-file.txt` is staged, the current version of the file will get added to the local repository next time we commit, which we do as follows:

```{bash, eval=FALSE}
git commit -m "adding a new file"
```

We have now changed the local repo, which you can confirm using

```{bash, eval=FALSE}
git status
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"/git/git-commit.png"))
```

However, if we edit that file again, it changes only in the working directory. To add to the local repo, we need to stage it and commit the changes that are added to the local repo:

```{bash, eval=FALSE}
echo "adding a line" >> new-file.txt
git add new-file.txt
git commit -m "adding a new line to new-file"
```

Note that this step is often unnecessary in our uses of Git. We can skip the staging part if we add the file name to the commit command like this:

```{bash, eval=FALSE}
echo "adding a second line" >> new-file.txt
git commit -m "minor change to new-file" new-file.txt
```

We can keep track of all the changes we have made with:

```{bash, eval=FALSE}
git log new-file.txt
```

To keep everything synced, the final step is to push the changes to the upstream repo. This is done with the `git push` command like this:

```{bash, eval=FALSE}
git push
```

```{r, include=FALSE}
knitr::opts_knit$set(root.dir = wd)
```

```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-push.png"))
```

However, in this particular example, you will not be able to do this because you do not have permission to edit the upstream repo. If this was your repo, you could.

If this is a collaborative project, the upstream repo may change and become different than our version. To update our local repository to be like the upstream repo, we use the command `fetch`:

```{bash, eval=FALSE}
git fetch
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-fetch.png"))
```


And then to make these copies to the staging and working directory areas, we use the command:

```{bash, eval=FALSE}
git merge
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-merge.png"))
```

However, we often just want to change both with one command. For this, we use:

```{bash, eval=FALSE}
git pull
```


```{r, echo=FALSE}
knitr::include_graphics(file.path(img_path,"git/git-pull.png"))
```


We will learn in Section \@ref(rstudio-git) how RStudio has buttons to do all this. The details provided here should help you understand what happens in the background.


### Using Git and GitHub in RStudio {#rstudio-git}

While command line Git is a powerful and flexible tool, it can be somewhat daunting when we are getting started. RStudio provides a graphical interface that facilitates the use of Git in the context of a data analysis project. We describe how to use this RStudio feature to do this here.

Now we are ready to start an RStudio project that uses version control and stores the code on a GitHub repo. To do this, we start a project but, instead of _New Directory_, we will select _Version Control_ and then we will select _Git_ as our version control system:

```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[86:87])
```

The repository URL is the link you used to clone. In Section \@ref(github-repos), we used `https://github.com/username/homework-0.git` as an example. In the project directory name, you need to put the name of the folder that was generated, which in our example will be the name of the repo `homework-0`. This will create a folder called `homework-0` on your local system. Once you do this, the project is created and it is aware of the connection to a GitHub repo. You will see on the top right corner the name and type of project as well as a new tab on the upper right pane titled _Git_.


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[88:89])
```


If you select this tab, it will show you the files on your project with some icons that give you information about these files and their relationship to the repo. In the example below, we already added a file to the folder, called _code.R_ which you can see in the editing pane.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[90])
```

We now need to pay attention to the Git pane. It is important to know that **your local files and the GitHub repo will not be synced automatically**.  As described in Section \@ref(git-overview), you have to sync using git push when you are ready. We show you can do this through RStudio rather than the terminal below.

Before we start working on a collaborative project, usually the first thing we do is _pull_ in the changes from the remote repo, in our case the one on GitHub. However, for the example shown here, since we are starting with an empty repo and we are the only ones making changes, we don't need to start by pulling.

In RStudio, the status of the file as it relates to the remote and local repos are represented in the status symbols with colors. A yellow square means that Git knows nothing about this file. To sync with the GitHub repo, we need to _add_ the file, then _commit_ the change to our local Git repo, then _push_ the change to the GitHub repo. Right now, the file is just on our computer. To add the file using RStudio, we click the _Stage_ box. You will see that the status icon now changes to a green A.


```{r, echo=FALSE}
knitr::include_graphics(screenshots[91])
```

Note: we are only adding the _code.R_ file. We don't necessarily need to add all the files in our local repo to the GitHub repo, only the ones we want to keep track of or the ones we want to share. If our work is producing files of a certain type that we do not want to keep track of, we can add the suffix that defines these files to the .gitignore file. More details on using .gitignore are included here: [https://git-scm.com/docs/gitignore](https://git-scm.com/docs/gitignore). These files will stop appearing in your RStudio Git pane. For the example shown here, we will only be adding _code.R_. But, in general, for an RStudio project, we recommend adding both the .gitignore and .Rproj files.

Now we are ready to commit the file to our local repo. In RStudio, we can use the _Commit_ button. This will open a new dialog window. With Git, whenever we commit a change, we are required to enter a comment describing the changes being _committed_.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[92])
```

In this case, we will simply describe that we are adding a new script. In this dialog box, RStudio also gives you a summary of what you are changing to the GitHub repo. In this case, because it is a new file, the entire file is highlighted as green, which highlights the changes.

Once we hit the commit button, we should see a message from Git with a summary of the changes that were committed. Now we are ready to _push_ these changes to the GitHub repo. We can do this by clicking on the _Push_ button on the top right corner:

```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[93:94])
```

We now see a message from Git letting us know that the push has succeeded.
In the pop-up window we no longer see the `code.R` file. This is because no new changes have been performed since we last pushed. We can exit this pop-up window now and continue working on our code.


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[95:96])
```

If we now visit our repo on the web, we will see that it matches our local copy.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[97])
```

Congratulations, you have successfully shared code on a GitHub repository!

```{r, include=FALSE}
knitr::opts_chunk$set(out.width = NULL, out.extra = NULL)
```

## R

The final product of a data analysis project is often a report. Many scientific publications can be thought of as a final report of a data analysis. The same is true for news articles based on data, an analysis report for your company, or lecture notes for a class on how to analyze data. The reports are often on paper or in a PDF that includes a textual description of the findings along with some figures and tables resulting from the analysis.

Imagine that after you finish the analysis and the report, you are told that you were given the wrong dataset, you are sent a new one and you are asked to run the same analysis with this new dataset. Or what if you realize that a mistake was made and need to re-examine the code, fix the error, and re-run the analysis? Or imagine that someone you are training wants to see the code and be able to reproduce the results to learn about your approach?

Situations like the ones just described are actually quite common for a data scientist. Here, we describe how you can keep your data science projects organized with RStudio so that re-running an analysis is straight-forward. We then demonstrate how to generate reproducible reports with R markdown and the __knitR__ package in a way that will greatly help with recreating reports with minimal work. This is possible due to the fact that R markdown documents permit code and textual descriptions to be combined into the same document, and the figures and tables produced by the code are automatically added to the document.

### RStudio projects

RStudio provides a way to keep all the components of a data analysis project organized into one folder and to keep track of information about this project, such as the Git status of files, in one file. In Section \@ref(rstudio-git) we demonstrate how RStudio facilitates the use of Git and GitHub through RStudio projects. In this section we quickly demonstrate how to start a new a project and some recommendations on how to keep these organized. RStudio projects also permit you to have several RStudio sessions open and keep track of which is which.

To start a project, click on _File_ and then _New Project_. Often we have already created a folder to save the work, as we did in Section \@ref(prep-project) and we select _Existing Directory_. Here we show an example
in which we have not yet created a folder and select the _New Directory_ option.

```{r, echo=FALSE}
knitr::include_graphics(screenshots[49:50])
```

Then, for a data analysis project, you usually select the  _New Project_ option:

```{r, echo=FALSE, out.width="70%"}
knitr::include_graphics(screenshots[51])
```

Now you will have to decide on the location of the folder that will be associated with your project, as well as the name of the folder. When choosing a folder name, just like with file names, make sure it is a meaningful name that will help you remember what the project is about. As with files, we recommend using lower case letters, no spaces, and hyphens to separate words. We will call the folder for this project _my-first-project_. This will then generate a _Rproj_ file called _my-first-project.Rproj_ in the folder associated with the project. We will see how this is useful a few lines below.

```{r, echo=FALSE, out.width="70%"}
knitr::include_graphics(screenshots[52])
```

You will be given options on where this folder should be on your filesystem. In this example, we will place it in our home folder, but this is generally not good practice. As we described in Section \@ref(prep-project) in the Unix chapter, you want to organize your filesystem following a hierarchical approach and with a folder called _projects_ where you keep a folder for each project.

```{r, echo=FALSE, out.width="70%"}
knitr::include_graphics(screenshots[53])
```

When you start using RStudio with a project, you will see the project name in the upper left corner. This will remind you what project this particular RStudio session belongs to. When you open an RStudio session with no project, it will say _Project: (None)_.

When working on a project, all files will be saved and searched for in the folder associated with the project. Below, we show an example of a script that we wrote and saved with the name _code.R_. Because we used a meaningful name for the project, we can be a bit less informative when we name the files. Although we do not do it here, you can have several scripts open at once. You simply need to click _File_, then _New File_ and pick the type of file you want to edit.


```{r, echo=FALSE, out.width="70%"}
knitr::include_graphics(screenshots[54])
```

One of the main advantages of using Projects is that after closing RStudio, if we wish to continue where we left off on the project, we simply double click or open the file saved when we first created the RStudio project. In this case, the file is called _my-first-project.Rproj_. If we open this file, RStudio will start up and open the scripts we were editing.


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[55:56])
```

Another advantage is that if you click on two or more different Rproj files,  you start new RStudio and R sessions for each.


### R markdown

R markdown is a format for _literate programming_ documents. It is based on _markdown_, a markup language that is widely used to generate html pages. You can learn more about markdown here: [https://www.markdowntutorial.com/](https://www.markdowntutorial.com/). Literate programming weaves instructions, documentation, and detailed comments in between machine executable code, producing a document that describes the program that is best for human understanding (Knuth 1984). Unlike a word processor, such as Microsoft Word, where what you see is what you get, with R markdown, you need to _compile_ the document into the final report. The R markdown document looks different than the final product. This seems like a disadvantage at first, but it is not because, for example, instead of producing plots and inserting them one by one into the word processing document, the plots are automatically added.

In RStudio, you can start an R markdown document by clicking on _File_, _New File_, the _R Markdown_. You will then be asked to enter a title and author for your document. We are going to prepare a report on gun murders so we will give it an appropriate name. You can also decide what format you would like the final report to be in: HTML, PDF, or Microsoft Word. Later, we can easily change this, but here we select html as it is the preferred format for debugging purposes:


```{r, echo=FALSE, out.width="45%"}
knitr::include_graphics(screenshots[104:105])
```

This will generate a template file:

```{r, echo=FALSE, out.width="70%"}
knitr::include_graphics(screenshots[106])
```

As a convention, we use the `Rmd` suffix for these files.

Once you gain experience with R Markdown, you will be able to do this without the template and can simply start from a blank template.

In the template, you will see several things to note.


#### The header

At the top you see:

```
---
title: "Report on Gun Murders"
author: "Rafael Irizarry"
date: "April 16, 2018"
output: html_document
---
```

The things between the `---` is the header. We actually don't need a header, but it is often useful. You can define many other things in the header than what is included in the template. We don't discuss those here, but much information is available online. The one parameter that we will highlight is `output`. By changing this to, say, `pdf_document`, we can control the type of output that is produced when we compile.

#### R code chunks

In various places in the document, we see something like this:

````
```{r}`r ''`
summary(pressure)
```
````

These are the code chunks. When you compile the document, the R code inside the chunk, in this case `summary(pressure)`, will be evaluated and the result included in that position in the final document.

To add your own R chunks, you can type the characters above quickly with the key binding command-option-I on the Mac and Ctrl-Alt-I on Windows.

This applies to plots as well; the plot will be placed in that position. We can write something like this:


````
```{r}`r ''`
plot(pressure)
```
````

By default, the code will show up as well. To avoid having the code show up, you can use an argument. To avoid this, you can use the argument `echo=FALSE`. For example:




````
```{r echo=FALSE}`r ''`
summary(pressure)
```
````


We recommend getting into the habit of adding a label to the R code chunks. This will be very useful when debugging, among other situations. You do this by adding a descriptive word like this:



````
```{r pressure-summary}`r ''`
summary(pressure)
```
````


#### Global options

One of the R chunks contains a complex looking call:



````
```{r setup, include=FALSE}`r ''`
knitr::opts_chunk$set(echo = TRUE)
```
````


We will not cover this here, but as you become more experienced with R Markdown, you will learn the advantages of setting global options for the compilation process.


#### knitR

We use the __knitR__ package to compile R markdown documents. The specific function used to compile is the `knit` function, which takes a filename as input.  RStudio provides a button that makes it easier to compile the document. For the screenshot below, we have edited the document so that a report on gun murders is produced. You can see the file here: [https://raw.githubusercontent.com/rairizarry/murders/master/report.Rmd](https://raw.githubusercontent.com/rairizarry/murders/master/report.Rmd). You can now click on the `Knit` button:

```{r, echo=FALSE}
knitr::include_graphics(screenshots[107])
```


The first time you click on the _Knit_ button, a dialog box may appear asking you to install packages you need.
<!--
```{r, echo=FALSE}
knitr::include_graphics(screenshots[108])
```
-->

Once you have installed the packages, clicking the _Knit_ will compile your R markdown file and the resulting document will pop up:


This produces an html document which you can see in your working directory. To view it, open a terminal and list the files. You can open the file in a browser and use this to present your analysis. You can also produce a PDF or Microsoft document by changing:

`output: html_document` to `output: pdf_document` or `output: word_document`.

We can also produce documents that render on GitHub using `output: github_document`.

This will produce a markdown file, with suffix `md`, that renders in GitHub. Because we have uploaded these files to GitHub, you can click on the `md` file and you will see the report as a webpage:


```{r, echo=FALSE}
knitr::include_graphics(screenshots[125])
```

This is a convenient way to share your reports.

#### More on R markdown

There is a lot more you can do with R markdown. We highly recommend you continue learning as you gain more experience writing reports in R. There are many free resources on the internet including:

* RStudio's tutorial: [https://rmarkdown.rstudio.com](https://rmarkdown.rstudio.com)
* The cheat sheet: [https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf)
* The knitR book: [https://yihui.name/knitr/](https://yihui.name/knitr/)


### Help for R

#### Searching for Help with R

Google is your friend. Searching for help, especially when you are not sure what you are looking for, is more art than science. Adding certain strings to the search query --- like "R", "tidyverse", or "ggplot" --- often helps. Some locations are high quality (anything to do with RStudio or tidyverse) while others are less good than they initially appear (sthda.com, r-statistics.co, rdocumentation.org).

#### Reproducible Examples

The best way to get help from other people is to create a **rep**roducible **ex**ample --- a so-called "reprex" --- which shows an example of the problem you are having. 

Install the **reprex** package:

```{r, eval=FALSE}
install.packages("reprex")
```

Load the library:

```{r}
library(reprex)
```

The code for your reproducible example needs to exist somewhere *before* you can use it to create your reprex. It is tempting to just grab it from the current file in which you are working, usually either a .R or .Rmd. Instead, I recommend creating a new file, dedicated to the example. Call it whatever.R. This makes everything easier, not least because some of the code you need, like the calls to *library* will often be many lines away, in your original file, from the code which is generating your error. Creating a stand-alone file helps to make the problem clear in your own head. Example:

```{r, eval=FALSE}
library(tidyverse)
mtcars %>% 
  mutate(new_var = mpg + cly)
```

Running this code produces an error because I have misspelled `cyl` as `cly`. Try it! To create a reprex:

1. Highlight the code.
1. Press Ctrl-C (or the equivalent) to copy the code to the clipboard.
1. Type `reprex()` at the R prompt.

The reproducible example now exists in two places. First, you can see it in the Viewer pane in RStudio. Second, it is on your clipboard. 

Next step is to go to [RStudio Community](https://community.rstudio.com/) (or whatever location at which you want to ask your question), create a new post, and paste in the reprex from your clipboard. Of course, you may first have to create an account. Also, your post will need a title, associated text and perhaps other information like tags. The key point is that using a reproducible example makes it much likelier that someone will answer your question.

[Here](https://community.rstudio.com/t/best-practices-how-to-prepare-your-own-data-for-use-in-a-reprex-if-you-can-t-or-don-t-know-how-to-reproduce-a-problem-with-a-built-in-dataset/5346) is advice about using your own data in making a reprex. [Datapasta](https://cran.r-project.org/web/packages/datapasta/vignettes/how-to-datapasta.html) may also be relevant. 
